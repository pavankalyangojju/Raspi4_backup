import threading
from collections import defaultdict
import cv2
import os
import numpy as np
import RPi.GPIO as GPIO
from mfrc522 import SimpleMFRC522
import time
from PIL import Image
import smbus2
import requests
from datetime import datetime
import tempfile

# GPIO Setup
BUZZER_PIN = 17
GREEN_LED_PIN = 26
RED_LED_PIN = 19
GPIO.setwarnings(False)
GPIO.setmode(GPIO.BCM)
GPIO.setup(BUZZER_PIN, GPIO.OUT)
GPIO.setup(GREEN_LED_PIN, GPIO.OUT)
GPIO.setup(RED_LED_PIN, GPIO.OUT)
GPIO.output(BUZZER_PIN, GPIO.LOW)
GPIO.output(GREEN_LED_PIN, GPIO.LOW)
GPIO.output(RED_LED_PIN, GPIO.LOW)

# LCD Setup
LCD_ADDR = 0x27
LCD_WIDTH = 16
LCD_CHR = 1
LCD_CMD = 0
LCD_BACKLIGHT = 0x08
ENABLE = 0b00000100
LINE_1 = 0x80
LINE_2 = 0xC0
bus = smbus2.SMBus(1)

# Telegram Config
BOT_TOKEN = "your_bot_token"
CHAT_ID = "your_chat_id"

# API Endpoint
API_URL = "http://localhost:5000/attendance"
attendance_log = defaultdict(list)

# Flags for thread communication
rfid_ready = threading.Event()
face_recognition_trigger = threading.Event()
stop_threads = threading.Event()
current_rfid = {"id": None}

# LCD Functions
def lcd_byte(bits, mode):
    high_bits = mode | (bits & 0xF0) | LCD_BACKLIGHT
    low_bits = mode | ((bits << 4) & 0xF0) | LCD_BACKLIGHT
    bus.write_byte(LCD_ADDR, high_bits)
    lcd_toggle_enable(high_bits)
    bus.write_byte(LCD_ADDR, low_bits)
    lcd_toggle_enable(low_bits)

def lcd_toggle_enable(bits):
    time.sleep(0.0005)
    bus.write_byte(LCD_ADDR, bits | ENABLE)
    time.sleep(0.0005)
    bus.write_byte(LCD_ADDR, bits & ~ENABLE)
    time.sleep(0.0005)

def lcd_init():
    lcd_byte(0x33, LCD_CMD)
    lcd_byte(0x32, LCD_CMD)
    lcd_byte(0x06, LCD_CMD)
    lcd_byte(0x0C, LCD_CMD)
    lcd_byte(0x28, LCD_CMD)
    lcd_byte(0x01, LCD_CMD)
    time.sleep(0.005)

def lcd_display(message, line):
    lcd_byte(line, LCD_CMD)
    message = message.ljust(LCD_WIDTH, ' ')
    for char in message:
        lcd_byte(ord(char), LCD_CHR)

def send_telegram_photo(img, caption):
    url = f"https://api.telegram.org/bot{BOT_TOKEN}/sendPhoto"
    try:
        with tempfile.NamedTemporaryFile(suffix=".jpg", delete=True) as temp:
            cv2.imwrite(temp.name, img)
            with open(temp.name, 'rb') as photo:
                files = {'photo': photo}
                data = {'chat_id': CHAT_ID, 'caption': caption}
                requests.post(url, files=files, data=data)
    except Exception as e:
        print(f"[ERROR] Telegram photo send failed: {e}")

def send_attendance_api(name, rfid, timestamp):
    payload = {"name": name, "rfid": rfid, "datetime": timestamp}
    try:
        response = requests.post(API_URL, json=payload)
        print("[INFO] API response:", response.status_code)
    except Exception as e:
        print("[ERROR] API failed:", e)

def rfid_reader_thread():
    reader = SimpleMFRC522()
    while not stop_threads.is_set():
        lcd_display("Scan RFID Card", LINE_1)
        lcd_display("", LINE_2)
        try:
            rfid_id, _ = reader.read()
            current_rfid["id"] = str(rfid_id)
            rfid_ready.set()
            face_recognition_trigger.set()
            time.sleep(1)
        except Exception as e:
            print("[ERROR] RFID read error:", e)
        time.sleep(1)

def face_recognition_thread():
    face_detector = cv2.CascadeClassifier("haarcascade_frontalface_default.xml")
    recognizer = cv2.face.LBPHFaceRecognizer_create()

    while not stop_threads.is_set():
        face_recognition_trigger.wait()
        rfid = current_rfid["id"]
        image_folder = os.path.join("dataset", rfid)

        if not os.path.exists(image_folder):
            lcd_display("Face Not Found", LINE_1)
            lcd_display("Access Denied", LINE_2)
            GPIO.output(RED_LED_PIN, GPIO.HIGH)
            time.sleep(2)
            GPIO.output(RED_LED_PIN, GPIO.LOW)
            face_recognition_trigger.clear()
            continue

        # Train model
        def get_images_and_labels(path):
            face_samples = []
            ids = []
            for file in os.listdir(path):
                if file.endswith('.jpg'):
                    img = Image.open(os.path.join(path, file)).convert('L')
                    img_np = np.array(img, 'uint8')
                    faces = face_detector.detectMultiScale(img_np)
                    for (x, y, w, h) in faces:
                        face_samples.append(img_np[y:y+h, x:x+w])
                        ids.append(1)
            return face_samples, ids

        faces, ids = get_images_and_labels(image_folder)
        recognizer.train(faces, np.array(ids))

        cam = cv2.VideoCapture(0)
        cam.set(3, 640)
        cam.set(4, 480)
        lcd_display("Face Detecting", LINE_1)

        while True:
            ret, img = cam.read()
            gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
            faces = face_detector.detectMultiScale(gray, 1.3, 5)

            for (x, y, w, h) in faces:
                id_pred, confidence = recognizer.predict(gray[y:y+h, x:x+w])
                if confidence < 40:
                    name_file = os.path.join(image_folder, "name.txt")
                    name = open(name_file).read().strip() if os.path.exists(name_file) else "Unknown"

                    now = datetime.now()
                    today_str = now.strftime("%Y-%m-%d")
                    timestamp = now.strftime("%Y-%m-%d %H:%M:%S")

                    if len([t for t in attendance_log[rfid] if t.startswith(today_str)]) >= 2:
                        lcd_display("Limit Reached", LINE_1)
                        lcd_display("Try Tomorrow", LINE_2)
                        send_telegram_photo(img, f"{name} tried third time today.")
                        time.sleep(2)
                        break

                    lcd_display("Access Granted", LINE_1)
                    lcd_display(name[:16], LINE_2)
                    GPIO.output(GREEN_LED_PIN, GPIO.HIGH)
                    GPIO.output(BUZZER_PIN, GPIO.HIGH)
                    time.sleep(1)
                    GPIO.output(GREEN_LED_PIN, GPIO.LOW)
                    GPIO.output(BUZZER_PIN, GPIO.LOW)

                    attendance_log[rfid].append(timestamp)
                    send_attendance_api(name, rfid, timestamp)
                    send_telegram_photo(img, f"{name} marked present.\nTime: {timestamp}")
                    time.sleep(2)
                    break
                else:
                    lcd_display("Face Unknown", LINE_1)
                    GPIO.output(BUZZER_PIN, GPIO.HIGH)
                    time.sleep(0.5)
                    GPIO.output(BUZZER_PIN, GPIO.LOW)
            if cv2.waitKey(1) & 0xFF == 27:
                break

        cam.release()
        cv2.destroyAllWindows()
        face_recognition_trigger.clear()

# ---- MAIN ----
if __name__ == "__main__":
    lcd_init()
    lcd_display("Attendance System", LINE_1)
    lcd_display("Initializing...", LINE_2)
    time.sleep(2)

    t1 = threading.Thread(target=rfid_reader_thread)
    t2 = threading.Thread(target=face_recognition_thread)

    t1.start()
    t2.start()

    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        print("[INFO] Shutting down...")
        stop_threads.set()
        t1.join()
        t2.join()
        lcd_display("System Stopped", LINE_1)
        lcd_display("", LINE_2)
        GPIO.cleanup()
