from collections import defaultdict
import cv2
import os
import numpy as np
import RPi.GPIO as GPIO
from mfrc522 import SimpleMFRC522
import time
from PIL import Image
import pigpio
from telegram import Update
from telegram.ext import Application, CommandHandler, CallbackContext

# GPIO Setup
GREEN_LED_PIN = 22
RELAY1_PIN = 26
RELAY2_PIN = 19
RELAY3_PIN = 13
RELAY4_PIN = 6
SERVO_PIN = 17
GPIO.setwarnings(False)
GPIO.setmode(GPIO.BCM)
GPIO.setup(GREEN_LED_PIN, GPIO.OUT)
GPIO.setup(RELAY1_PIN, GPIO.OUT)
GPIO.setup(RELAY2_PIN, GPIO.OUT)
GPIO.setup(RELAY3_PIN, GPIO.OUT)
GPIO.setup(RELAY4_PIN, GPIO.OUT)
GPIO.output(GREEN_LED_PIN, GPIO.LOW)
GPIO.output(RELAY1_PIN, GPIO.LOW)
GPIO.output(RELAY2_PIN, GPIO.LOW)
GPIO.output(RELAY3_PIN, GPIO.LOW)
GPIO.output(RELAY4_PIN, GPIO.LOW)

# Servo Setup
pi = pigpio.pi()
pi.set_mode(SERVO_PIN, pigpio.OUTPUT)

def set_servo_angle(angle):
    duty_cycle = int((angle / 180.0) * 2000 + 500)
    pi.set_servo_pulsewidth(SERVO_PIN, duty_cycle)
    time.sleep(1)
    pi.set_servo_pulsewidth(SERVO_PIN, 0)

# Telegram Bot Setup
TELEGRAM_BOT_TOKEN = "YOUR_BOT_TOKEN"

def relay_control(update: Update, context: CallbackContext):
    command = update.message.text.lower()
    if command == "/relay1_on":
        GPIO.output(RELAY1_PIN, GPIO.HIGH)
        update.message.reply_text("Relay 1 turned ON")
    elif command == "/relay1_off":
        GPIO.output(RELAY1_PIN, GPIO.LOW)
        update.message.reply_text("Relay 1 turned OFF")
    elif command == "/relay2_on":
        GPIO.output(RELAY2_PIN, GPIO.HIGH)
        update.message.reply_text("Relay 2 turned ON")
    elif command == "/relay2_off":
        GPIO.output(RELAY2_PIN, GPIO.LOW)
        update.message.reply_text("Relay 2 turned OFF")
    elif command == "/relay3_on":
        GPIO.output(RELAY3_PIN, GPIO.HIGH)
        update.message.reply_text("Relay 3 turned ON")
    elif command == "/relay3_off":
        GPIO.output(RELAY3_PIN, GPIO.LOW)
        update.message.reply_text("Relay 3 turned OFF")
    elif command == "/relay4_on":
        GPIO.output(RELAY4_PIN, GPIO.HIGH)
        update.message.reply_text("Relay 4 turned ON")
    elif command == "/relay4_off":
        GPIO.output(RELAY4_PIN, GPIO.LOW)
        update.message.reply_text("Relay 4 turned OFF")

# Initialize Telegram bot application
app = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
app.add_handler(CommandHandler(["relay1_on", "relay1_off", "relay2_on", "relay2_off", "relay3_on", "relay3_off", "relay4_on", "relay4_off"], relay_control))

# Start the bot
app.run_polling()

# RFID and Face Recognition Setup
reader = SimpleMFRC522()
face_detector = cv2.CascadeClassifier("haarcascade_frontalface_default.xml")
recognizer = cv2.face.LBPHFaceRecognizer_create()

attendance_log = defaultdict(list)

try:
    while True:
        print("\n[INFO] Please scan your RFID card...")
        try:
            rfid_id, rfid_text = reader.read()
            rfid_id = str(rfid_id)
            print(f"[INFO] RFID Scanned: {rfid_id}")
        except Exception as e:
            print(f"[ERROR] RFID Read Failed: {e}")
            GPIO.cleanup()
            break

        image_folder = os.path.join("dataset", rfid_id)
        if not os.path.exists(image_folder):
            print(f"[ERROR] No dataset folder found for RFID {rfid_id}")
            time.sleep(3)
            continue

        def get_images_and_labels(path):
            image_paths = [os.path.join(path, f) for f in os.listdir(path) if f.endswith('.jpg')]
            face_samples = []
            ids = []
            for image_path in image_paths:
                img = Image.open(image_path).convert('L')
                img_np = np.array(img, 'uint8')
                faces = face_detector.detectMultiScale(img_np)
                for (x, y, w, h) in faces:
                    face_samples.append(img_np[y:y+h, x:x+w])
                    ids.append(1)
            return face_samples, ids

        print("[INFO] Training model from RFID-specific folder...")
        faces, ids = get_images_and_labels(image_folder)
        recognizer.train(faces, np.array(ids))

        print("[INFO] Model trained. Look at the camera...")
        cam = cv2.VideoCapture(0)
        cam.set(3, 640)
        cam.set(4, 480)
        matched = False

        while True:
            ret, img = cam.read()
            if not ret or img is None:
                print("[ERROR] Failed to read from camera")
                continue

            img = cv2.flip(img, -1)
            gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
            faces = face_detector.detectMultiScale(gray, 1.3, 5)

            for (x, y, w, h) in faces:
                id_pred, confidence = recognizer.predict(gray[y:y+h, x:x+w])

                if confidence < 40:
                    name_file = os.path.join(image_folder, "name.txt")
                    if os.path.exists(name_file):
                        with open(name_file, "r") as f:
                            person_name = f.read().strip()
                    else:
                        person_name = "Matched"

                    print(f"[INFO] Face matched - {person_name} - Access Granted")
                    print("[INFO] Unlocking Door")
                    set_servo_angle(180)
                    time.sleep(2)
                    GPIO.output(RELAY1_PIN, GPIO.HIGH)
                    GPIO.output(RELAY2_PIN, GPIO.HIGH)
                    GPIO.output(RELAY3_PIN, GPIO.LOW)
                    GPIO.output(RELAY4_PIN, GPIO.LOW)
                    print("[INFO] Locking Door")
                    set_servo_angle(0)
                    for _ in range(2):
                        GPIO.output(GREEN_LED_PIN, GPIO.HIGH)
                        time.sleep(0.5)
                        GPIO.output(GREEN_LED_PIN, GPIO.LOW)
                        time.sleep(0.5)
                    matched = True
                    break

        cam.release()
        cv2.destroyAllWindows()
        time.sleep(3)

except KeyboardInterrupt:
    print("\n[INFO] Program interrupted. Exiting gracefully.")
    GPIO.cleanup()
    pi.stop()
    app.stop()
