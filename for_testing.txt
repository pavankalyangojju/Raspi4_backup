import cv2
import easyocr
import RPi.GPIO as GPIO
import time
import signal
import sys
import csv
import subprocess
import os
from datetime import datetime
from mfrc522 import SimpleMFRC522
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email import encoders
from RPLCD.i2c import CharLCD   # LCD library

# ---------------- Email config ----------------
SENDER_EMAIL = "msshyam0007@gmail.com"
SENDER_PASSWORD = "hmse leij pwzo uoxw"  # Gmail App Password
RECEIVER_EMAIL = "hemanthkumar04373@gmail.com"

LOG_FILE = "dispense_log.csv"

# ---------------- LCD setup ----------------
lcd = CharLCD('PCF8574', 0x27)

def lcd_display(message):
    lcd.clear()
    lcd.write_string(message[:32])  # truncate to avoid overflow
    print(f"LCD: {message}")

def lcd_clear():
    lcd.clear()
    print("LCD cleared")

# ---------------- Logging ----------------
def log_dispense_event(rfid_tag, user_name, timestamp):
    if not os.path.exists(LOG_FILE):
        with open(LOG_FILE, "w", newline="") as f:
            writer = csv.writer(f)
            writer.writerow(["RFID", "Name", "Timestamp"])
    with open(LOG_FILE, "a", newline="") as f:
        writer = csv.writer(f)
        writer.writerow([rfid_tag, user_name, timestamp])
    print(f"Logged dispense event: {rfid_tag}, {user_name}, {timestamp}")

# ---------------- Email ----------------
def send_email_with_video(video_path, user_name, timestamp):
    subject = f"Dispense Video - {user_name} - {timestamp}"
    body = f"Attached is the dispense video recorded on {timestamp} for user {user_name}."

    message = MIMEMultipart()
    message["From"] = SENDER_EMAIL
    message["To"] = RECEIVER_EMAIL
    message["Subject"] = subject
    message.attach(MIMEText(body, "plain"))

    with open(video_path, "rb") as f:
        part = MIMEBase("application", "octet-stream")
        part.set_payload(f.read())
    encoders.encode_base64(part)
    part.add_header("Content-Disposition", f"attachment; filename={os.path.basename(video_path)}")
    message.attach(part)

    try:
        server = smtplib.SMTP("smtp.gmail.com", 587)
        server.starttls()
        server.login(SENDER_EMAIL, SENDER_PASSWORD)
        server.sendmail(SENDER_EMAIL, RECEIVER_EMAIL, message.as_string())
        print("Email sent successfully with video attachment!")
    except Exception as e:
        print(f"Failed to send email: {e}")
    finally:
        server.quit()

# ---------------- Motor setup ----------------
motor1_in1 = 21
motor1_in2 = 20
motor2_in1 = 16
motor2_in2 = 12
motor1_en = 5
motor2_en = 6

GPIO.cleanup()
GPIO.setmode(GPIO.BCM)
GPIO.setup([motor1_in1, motor1_in2, motor2_in1, motor2_in2, motor1_en, motor2_en], GPIO.OUT)

GPIO.output(motor1_en, GPIO.LOW)
GPIO.output(motor2_en, GPIO.LOW)

def move_forward():
    lcd_display("Moving forward...")
    GPIO.output(motor1_en, GPIO.HIGH)
    GPIO.output(motor2_en, GPIO.HIGH)
    GPIO.output(motor1_in1, GPIO.HIGH)
    GPIO.output(motor1_in2, GPIO.LOW)
    GPIO.output(motor2_in1, GPIO.HIGH)
    GPIO.output(motor2_in2, GPIO.LOW)
    print("Moving forward...")

def move_backward():
    lcd_display("Moving backward...")
    GPIO.output(motor1_en, GPIO.HIGH)
    GPIO.output(motor2_en, GPIO.HIGH)
    GPIO.output(motor1_in1, GPIO.LOW)
    GPIO.output(motor1_in2, GPIO.HIGH)
    GPIO.output(motor2_in1, GPIO.LOW)
    GPIO.output(motor2_in2, GPIO.HIGH)
    print("Moving backward...")

def stop_motors():
    lcd_display("Motors stopped")
    GPIO.output(motor1_in1, GPIO.LOW)
    GPIO.output(motor1_in2, GPIO.LOW)
    GPIO.output(motor2_in1, GPIO.LOW)
    GPIO.output(motor2_in2, GPIO.LOW)
    GPIO.output(motor1_en, GPIO.LOW)
    GPIO.output(motor2_en, GPIO.LOW)
    print("Motors stopped.")

# ---------------- Ultrasonic setup ----------------
GPIO_TRIGGER = 17
GPIO_ECHO = 27
GPIO.setup(GPIO_TRIGGER, GPIO.OUT)
GPIO.setup(GPIO_ECHO, GPIO.IN)

def distance():
    GPIO.output(GPIO_TRIGGER, True)
    time.sleep(0.00001)
    GPIO.output(GPIO_TRIGGER, False)

    start_time = time.time()
    stop_time = time.time()

    timeout = time.time() + 0.05
    while GPIO.input(GPIO_ECHO) == 0 and time.time() < timeout:
        start_time = time.time()

    timeout = time.time() + 0.05
    while GPIO.input(GPIO_ECHO) == 1 and time.time() < timeout:
        stop_time = time.time()

    elapsed = stop_time - start_time
    dist = (elapsed * 34300) / 2
    return dist

def move_until_object(threshold=5.0):
    start = time.time()
    move_forward()
    while True:
        d = distance()
        print(f"Distance: {d:.2f} cm")
        if d <= threshold:
            stop_motors()
            forward_time = time.time() - start
            print("Object detected within threshold.")
            return forward_time
        time.sleep(0.05)

# ---------------- Servo setup ----------------
SERVO_INDEX_PIN = 14
SERVO_DOOR_PIN = 26
GPIO.setup(SERVO_INDEX_PIN, GPIO.OUT)
GPIO.setup(SERVO_DOOR_PIN, GPIO.OUT)

servo_index = GPIO.PWM(SERVO_INDEX_PIN, 50)
servo_door = GPIO.PWM(SERVO_DOOR_PIN, 50)
servo_index.start(0)
servo_door.start(0)

DOOR_OPEN = 60
DOOR_CLOSE = 180

def angle_to_duty(angle):
    return 2 + (angle / 18)

def set_angle(angle, hold=0.5):
    duty = 2 + (angle / 18)
    GPIO.output(SERVO_DOOR_PIN, True)
    servo_door.ChangeDutyCycle(duty)
    time.sleep(hold)
    GPIO.output(SERVO_DOOR_PIN, False)
    servo_door.ChangeDutyCycle(0)

def index_servo_to_angle(angle, hold=1.0):
    # Move index servo to a specific angle
    lcd_display(f"Index servo {angle} deg")
    duty = angle_to_duty(angle)
    servo_index.ChangeDutyCycle(duty)
    time.sleep(hold)
    servo_index.ChangeDutyCycle(0)

def door_open():
    lcd_display("Door opened")
    set_angle(DOOR_OPEN, hold=1.0)
    print("Door opened")

def door_close():
    lcd_display("Thank You")
    set_angle(DOOR_CLOSE, hold=1.0)
    print("Door closed")

# ---------------- RFID dictionary ----------------
# 'part' can be used for user-specific default slot if needed.
rfid = {
    "353610563795": {"name": "Hemanth", "part": 2}
}

# ---------------- Bluetooth speech ----------------
def speak(message):
    print(f"TTS: {message}")
    lcd_display(message)   # Show on LCD
    try:
        tmp_wav = "/tmp/tts.wav"
        subprocess.run(["pico2wave", "-w", tmp_wav, message], check=True)
        subprocess.run(["paplay", tmp_wav], check=True)
    except Exception as e:
        print(f"pico2wave/paplay failed ({e}), trying espeak...")
        try:
            subprocess.run(["espeak", message], check=True)
        except Exception as e2:
            print(f"espeak failed: {e2}")

# ---------------- RFID setup ----------------
reader_rfid = SimpleMFRC522()

def read_rfid():
    lcd_display("Scan RFID card...")
    print("Place your RFID card near the reader...")
    id, text = reader_rfid.read()
    rfid_key = str(id).strip().replace(" ", "")
    print(f"Card ID: {id}, Data: {text}, Normalized key: '{rfid_key}'")
    return rfid_key

# ---------------- OCR setup ----------------
reader = easyocr.Reader(['en'])
cap = cv2.VideoCapture(0)
cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)
frame_count = 0

# ---------------- Time-based Index Servo ----------------
# Map parts to angles: 1->0°, 2->90°, 3->180°
PART_ANGLE = {1: 0, 2: 90, 3: 180}

def move_servo_by_time():
    now = datetime.now()
    hour = now.hour

    if 6 <= hour < 12:
        part = 1   # Morning
        lcd_display("Morning: Part 1")
        angle = PART_ANGLE[part]
        index_servo_to_angle(angle)

    elif 12 <= hour < 18:
        part = 2   # Afternoon
        lcd_display("Afternoon: Part 2")
        angle = PART_ANGLE[part]
        index_servo_to_angle(angle)

    else:
        part = 3   # Night
        lcd_display("Night: Part 3")
        angle = PART_ANGLE[part]
        index_servo_to_angle(angle)

# ---------------- Dispense logic ----------------
def dispense_tablet(tag, forward_time):
    now = datetime.now()
    if tag in rfid:
        name = rfid[tag]['name']
        speak(f"Hello {name}, please take your tablets")

        # Time-based index selection (morning/afternoon/night)
        move_servo_by_time()

        # Open door to dispense
        door_open()

        # Record video
        video_filename = f"dispense_{now.strftime('%Y%m%d_%H%M%S')}.avi"
        fourcc = cv2.VideoWriter_fourcc(*'XVID')
        out = cv2.VideoWriter(video_filename, fourcc, 20.0, (640, 480))

        start_time = time.time()
        while time.time() - start_time < 10:
            ret, frame = cap.read()
            if ret:
                out.write(frame)
            else:
                time.sleep(0.05)
        out.release()
        print(f"Video saved as {video_filename}")

        timestamp = now.strftime("%Y-%m-%d %H:%M:%S")
        send_email_with_video(video_filename, name, timestamp)
        log_dispense_event(tag, name, timestamp)

        time.sleep(3)
        door_close()

        # Reset index servo to 0° after door closes
        lcd_display("Reset index to 0°")
        index_servo_to_angle(0)

        print("Dispense complete.")

        # Return to original position
        move_backward()
        time.sleep(forward_time)
        stop_motors()
        lcd_clear()   # Clear LCD after backward movement
        print("Process complete.")

    else:
        available = ", ".join(rfid.keys())
        speak("Invalid user")
        print(f"Invalid user. Read tag='{tag}'. Known keys=[{available}]")

        move_backward()
        time.sleep(forward_time)
        stop_motors()
        lcd_clear()   # Clear LCD after backward movement
        print("Returned due to invalid user.")

# ---------------- Safe exit handler ----------------
def safe_exit(sig, frame):
    print("Force exit detected, stopping motors...")
    try:
        stop_motors()
    except Exception:
        pass
    GPIO.output(motor1_en, GPIO.LOW)
    GPIO.output(motor2_en, GPIO.LOW)
    try:
        cap.release()
    except Exception:
        pass
    try:
        servo_index.stop()
        servo_door.stop()
    except Exception:
        pass
    lcd_clear()
    GPIO.cleanup()
    sys.exit(0)

signal.signal(signal.SIGINT, safe_exit)
signal.signal(signal.SIGTERM, safe_exit)

# ---------------- Object handling logic ----------------
def handle_object_detection():
    d = distance()
    print(f"Distance: {d:.2f} cm")

    if d < 10:
        # Stop immediately if object too close
        stop_motors()
        lcd_display("Object <10cm: Stopped")
        print("Stopped due to object <10cm")
        return None   # No RFID check

    elif 10 <= d <= 20:
        # Pause and check RFID
        stop_motors()
        lcd_display("Object 10-20cm: Checking RFID")
        print("Object between 10-20cm, checking RFID...")
        tag = read_rfid()
        return tag    # Return RFID tag for further processing

    else:
        # Keep moving forward
        move_forward()
        return None

# ---------------- Main flow ----------------
try:
    while True:
        d = distance()
        if d > 10:  # Only proceed if no object within 10 cm
            ret, frame = cap.read()
            if not ret:
                print("Camera frame not available; retrying...")
                time.sleep(0.2)
                continue

            frame_count += 1
            if frame_count % 10 == 0:
                results = reader.readtext(frame)
                for (_, text, prob) in results:
                    digits = ''.join([c for c in text if c.isdigit()])
                    if digits == "2":
                        print("Digit '2' detected and no object within 10cm!")
                        move_forward()

                        while True:
                            tag = handle_object_detection()
                            if tag:   # RFID was checked
                                forward_time = move_until_object(threshold=13.0)
                                dispense_tablet(tag, forward_time)
                                break
                            time.sleep(0.1)
                        break
        else:
            print(f"Object detected at {d:.2f} cm — waiting...")
            time.sleep(0.2)

except Exception as e:
    print(f"Error occurred: {e}")

finally:
    try:
        cap.release()
    except Exception:
        pass
    try:
        servo_index.stop()
        servo_door.stop()
    except Exception:
        pass
    stop_motors()
    GPIO.output(motor1_en, GPIO.LOW)
    GPIO.output(motor2_en, GPIO.LOW)
    lcd_clear()
    GPIO.cleanup()

