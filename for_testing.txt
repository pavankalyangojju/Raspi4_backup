from collections import defaultdict
import cv2
import os
import numpy as np
import RPi.GPIO as GPIO
from mfrc522 import SimpleMFRC522
import time
from PIL import Image
import smbus2
from datetime import datetime
import tempfile
import sys
import subprocess
import threading
from telegram.ext import Application, MessageHandler, filters

# GPIO Setup
BUZZER_PIN = 17
GREEN_LED_PIN = 26
RED_LED_PIN = 19
SERVO_PIN = 18
RELAY_PINS = [17, 27, 22, 5]

GPIO.setwarnings(False)
GPIO.setmode(GPIO.BCM)
GPIO.setup(BUZZER_PIN, GPIO.OUT)
GPIO.setup(GREEN_LED_PIN, GPIO.OUT)
GPIO.setup(RED_LED_PIN, GPIO.OUT)
GPIO.setup(SERVO_PIN, GPIO.OUT)
for pin in RELAY_PINS:
    GPIO.setup(pin, GPIO.OUT)
    GPIO.output(pin, GPIO.LOW)

GPIO.output(BUZZER_PIN, GPIO.LOW)
GPIO.output(GREEN_LED_PIN, GPIO.LOW)
GPIO.output(RED_LED_PIN, GPIO.LOW)

servo = GPIO.PWM(SERVO_PIN, 50)
servo.start(0)

# Telegram Bot Setup
BOT_TOKEN = '7038070025:AAHOoUWmqVPvFmmITJKpbWVGcdwzLDmcVJI'
CHAT_ID = '1367693706'

def relay_control(update, context):
    msg = update.message.text.lower()
    if msg == 'on1':
        GPIO.output(RELAY_PINS[0], GPIO.HIGH)
    elif msg == 'off1':
        GPIO.output(RELAY_PINS[0], GPIO.LOW)
    elif msg == 'on2':
        GPIO.output(RELAY_PINS[1], GPIO.HIGH)
    elif msg == 'off2':
        GPIO.output(RELAY_PINS[1], GPIO.LOW)
    elif msg == 'on3':
        GPIO.output(RELAY_PINS[2], GPIO.HIGH)
    elif msg == 'off3':
        GPIO.output(RELAY_PINS[2], GPIO.LOW)
    elif msg == 'on4':
        GPIO.output(RELAY_PINS[3], GPIO.HIGH)
    elif msg == 'off4':
        GPIO.output(RELAY_PINS[3], GPIO.LOW)

application = Application.builder().token(BOT_TOKEN).build()
application.add_handler(MessageHandler(filters.TEXT & (~filters.COMMAND), relay_control))
threading.Thread(target=application.run_polling, daemon=True).start()

# LCD Setup
LCD_ADDR = 0x27
LCD_WIDTH = 16
LCD_CHR = 1
LCD_CMD = 0
LCD_BACKLIGHT = 0x08
ENABLE = 0b00000100
LINE_1 = 0x80
LINE_2 = 0xC0
bus = smbus2.SMBus(1)

def lcd_byte(bits, mode):
    high_bits = mode | (bits & 0xF0) | LCD_BACKLIGHT
    low_bits = mode | ((bits << 4) & 0xF0) | LCD_BACKLIGHT
    bus.write_byte(LCD_ADDR, high_bits)
    lcd_toggle_enable(high_bits)
    bus.write_byte(LCD_ADDR, low_bits)
    lcd_toggle_enable(low_bits)

def lcd_toggle_enable(bits):
    time.sleep(0.0005)
    bus.write_byte(LCD_ADDR, bits | ENABLE)
    time.sleep(0.0005)
    bus.write_byte(LCD_ADDR, bits & ~ENABLE)
    time.sleep(0.0005)

def lcd_init():
    lcd_byte(0x33, 0)
    lcd_byte(0x32, 0)
    lcd_byte(0x06, 0)
    lcd_byte(0x0C, 0)
    lcd_byte(0x28, 0)
    lcd_byte(0x01, 0)
    time.sleep(0.005)

def lcd_display(message, line):
    lcd_byte(line, 0)
    message = message.ljust(LCD_WIDTH, ' ')
    for char in message:
        lcd_byte(ord(char), 1)

def rotate_servo():
    def angle_to_duty(angle):
        return 2 + (angle / 18)
    for angle in range(0, 181, 5):
        servo.ChangeDutyCycle(angle_to_duty(angle))
        time.sleep(0.02)
    servo.ChangeDutyCycle(0)
    time.sleep(10)
    for angle in range(180, -1, -5):
        servo.ChangeDutyCycle(angle_to_duty(angle))
        time.sleep(0.02)
    servo.ChangeDutyCycle(0)

def restart_program():
    python = sys.executable
    os.execl(python, python, *sys.argv)

lcd_init()
lcd_display("Welcome to", LINE_1)
lcd_display("AttendanceSystem", LINE_2)
time.sleep(2)

attendance_log = defaultdict(list)
reader = SimpleMFRC522()
face_detector = cv2.CascadeClassifier("haarcascade_frontalface_default.xml")
recognizer = cv2.face.LBPHFaceRecognizer_create()

try:
    while True:
        lcd_display("Scan your", LINE_1)
        lcd_display("RFID Card...", LINE_2)
        cam = cv2.VideoCapture(0)
        cam.set(3, 640)
        cam.set(4, 480)
        try:
            rfid_id, rfid_text = reader.read()
            rfid_id = str(rfid_id)
            lcd_display("RFID Found", LINE_1)
            lcd_display("Processing...", LINE_2)
        except Exception as e:
            lcd_display("RFID Read Error", LINE_1)
            lcd_display("Please Retry", LINE_2)
            GPIO.cleanup()
            break

        image_folder = os.path.join("dataset", rfid_id)
        if not os.path.exists(image_folder):
            lcd_display("No Data Found", LINE_1)
            lcd_display("Access Denied", LINE_2)
            time.sleep(3)
            continue

        def get_images_and_labels(path):
            image_paths = [os.path.join(path, f) for f in os.listdir(path) if f.endswith('.jpg')]
            face_samples = []
            ids = []
            for image_path in image_paths:
                img = Image.open(image_path).convert('L')
                img_np = np.array(img, 'uint8')
                faces = face_detector.detectMultiScale(img_np)
                for (x, y, w, h) in faces:
                    face_samples.append(img_np[y:y+h, x:x+w])
                    ids.append(1)
            return face_samples, ids

        lcd_display("Training Face", LINE_1)
        lcd_display("Please Wait...", LINE_2)
        faces, ids = get_images_and_labels(image_folder)
        recognizer.train(faces, np.array(ids))

        lcd_display("Look at Camera", LINE_1)
        lcd_display("Verifying...", LINE_2)
        matched = False

        while True:
            ret, img = cam.read()
            if not ret or img is None:
                cam.release()
                cv2.destroyAllWindows()
                time.sleep(2)
                restart_program()

            img = cv2.flip(img, -1)
            gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
            faces = face_detector.detectMultiScale(gray, 1.3, 5)

            for (x, y, w, h) in faces:
                id_pred, confidence = recognizer.predict(gray[y:y+h, x:x+w])
                if confidence < 40:
                    name_file = os.path.join(image_folder, "name.txt")
                    person_name = open(name_file).read().strip() if os.path.exists(name_file) else "Matched"
                    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                    lcd_display("Your Attendance", LINE_1)
                    lcd_display(f"Welcome {person_name[:9]}", LINE_2)
                    GPIO.output(BUZZER_PIN, GPIO.HIGH)
                    GPIO.output(GREEN_LED_PIN, GPIO.HIGH)
                    time.sleep(0.2)
                    GPIO.output(BUZZER_PIN, GPIO.LOW)
                    time.sleep(3)
                    GPIO.output(GREEN_LED_PIN, GPIO.LOW)
                    rotate_servo()
                    GPIO.output(RELAY_PINS[0], GPIO.HIGH)
                    GPIO.output(RELAY_PINS[2], GPIO.HIGH)
                    GPIO.output(RELAY_PINS[1], GPIO.LOW)
                    GPIO.output(RELAY_PINS[3], GPIO.LOW)
                    matched = True
                    break
                else:
                    lcd_display("Unknown Face", LINE_1)
                    lcd_display("Access Denied", LINE_2)
                    for _ in range(2):
                        GPIO.output(BUZZER_PIN, GPIO.HIGH)
                        time.sleep(0.2)
                        GPIO.output(BUZZER_PIN, GPIO.LOW)
                        time.sleep(0.2)
                    GPIO.output(RED_LED_PIN, GPIO.HIGH)
                    time.sleep(3)
                    GPIO.output(RED_LED_PIN, GPIO.LOW)
                    lcd_display("Put Correct", LINE_1)
                    lcd_display("Face", LINE_2)

            cv2.imshow("camera", img)
            if matched or cv2.waitKey(1) & 0xFF == 27:
                break

        cam.release()
        cv2.destroyAllWindows()
        time.sleep(3)

except KeyboardInterrupt:
    lcd_display("Welcome to", LINE_1)
    lcd_display("AttendanceSystem", LINE_2)
    time.sleep(2)
    servo.stop()
    GPIO.cleanup()
