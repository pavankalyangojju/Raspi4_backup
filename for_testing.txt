from collections import defaultdict
import cv2
import os
import numpy as np
import RPi.GPIO as GPIO
from mfrc522 import SimpleMFRC522
import time
from PIL import Image
import smbus2
from datetime import datetime
import sys
import threading
import requests

# GPIO Setup
BUZZER_PIN = 17
GREEN_LED_PIN = 26
RED_LED_PIN = 19
SERVO_PIN = 18
RELAY_PINS = {
    "relay1": 21,
    "relay2": 27,
    "relay3": 22,
    "relay4": 5,
}

GPIO.setwarnings(False)
GPIO.setmode(GPIO.BCM)

# Initialize all outputs
for pin in RELAY_PINS.values():
    GPIO.setup(pin, GPIO.OUT)
    GPIO.output(pin, GPIO.HIGH)

GPIO.setup(BUZZER_PIN, GPIO.OUT)
GPIO.setup(GREEN_LED_PIN, GPIO.OUT)
GPIO.setup(RED_LED_PIN, GPIO.OUT)
GPIO.setup(SERVO_PIN, GPIO.OUT)

# Initialize all outputs to LOW
GPIO.output(BUZZER_PIN, GPIO.LOW)
GPIO.output(GREEN_LED_PIN, GPIO.LOW)
GPIO.output(RED_LED_PIN, GPIO.LOW)

# Servo PWM setup
servo = GPIO.PWM(SERVO_PIN, 50)
servo.start(0)

# Telegram Bot Setup
BOT_TOKEN = "7038070025:AAHOoUWmqVPvFmmITJKpbWVGcdwzLDmcVJI"
BASE_URL = f"https://api.telegram.org/bot{BOT_TOKEN}"
last_update_id = 0

def handle_telegram():
    global last_update_id
    print("[INFO] Telegram listener started...")
    while True:
        try:
            url = f"{BASE_URL}/getUpdates?offset={last_update_id + 1}&timeout=10"
            res = requests.get(url).json()

            for update in res.get("result", []):
                last_update_id = update["update_id"]
                msg = update.get("message", {}).get("text", "").lower()
                chat_id = update["message"]["chat"]["id"]
                print(f"[TELEGRAM] Received: {msg}")

                if msg == "/relayall_on":
                    for pin in RELAY_PINS.values():
                        GPIO.output(pin, GPIO.HIGH)
                    response = "All relays turned ON"
                elif msg == "/relayall_off":
                    for pin in RELAY_PINS.values():
                        GPIO.output(pin, GPIO.LOW)
                    response = "All relays turned OFF"
                elif msg.startswith("/relay"):
                    parts = msg.split("_")
                    if len(parts) == 2:
                        relay, state = parts
                        relay = relay.lstrip("/")
                        if relay in RELAY_PINS:
                            GPIO.output(RELAY_PINS[relay], GPIO.HIGH if state == "on" else GPIO.LOW)
                            response = f"{relay} turned {state.upper()}"
                        else:
                            response = "Invalid relay name"
                    else:
                        response = "Invalid format. Use /relay1_on"
                else:
                    response = "Unknown command"

                requests.post(f"{BASE_URL}/sendMessage", json={"chat_id": chat_id, "text": response})
        except Exception as e:
            print(f"[ERROR] Telegram handler: {e}")
        time.sleep(2)

# Start Telegram handler thread
threading.Thread(target=handle_telegram, daemon=True).start()

# LCD Setup
LCD_ADDR = 0x27
LCD_WIDTH = 16
LCD_CHR = 1
LCD_CMD = 0
LCD_BACKLIGHT = 0x08
ENABLE = 0b00000100
LINE_1 = 0x80
LINE_2 = 0xC0
bus = smbus2.SMBus(1)

# LCD functions
def lcd_byte(bits, mode):
    high_bits = mode | (bits & 0xF0) | LCD_BACKLIGHT
    low_bits = mode | ((bits << 4) & 0xF0) | LCD_BACKLIGHT
    bus.write_byte(LCD_ADDR, high_bits)
    lcd_toggle_enable(high_bits)
    bus.write_byte(LCD_ADDR, low_bits)
    lcd_toggle_enable(low_bits)

def lcd_toggle_enable(bits):
    time.sleep(0.0005)
    bus.write_byte(LCD_ADDR, bits | ENABLE)
    time.sleep(0.0005)
    bus.write_byte(LCD_ADDR, bits & ~ENABLE)
    time.sleep(0.0005)

def lcd_init():
    lcd_byte(0x33, LCD_CMD)
    lcd_byte(0x32, LCD_CMD)
    lcd_byte(0x06, LCD_CMD)
    lcd_byte(0x0C, LCD_CMD)
    lcd_byte(0x28, LCD_CMD)
    lcd_byte(0x01, LCD_CMD)
    time.sleep(0.005)

def lcd_display(message, line):
    lcd_byte(line, LCD_CMD)
    message = message.ljust(LCD_WIDTH, ' ')
    for char in message:
        lcd_byte(ord(char), LCD_CHR)

def rotate_servo():
    def angle_to_duty(angle):
        return 2 + (angle / 18)

    for angle in range(0, 181, 5):
        servo.ChangeDutyCycle(angle_to_duty(angle))
        time.sleep(0.02)
    servo.ChangeDutyCycle(0)
    time.sleep(10)
    for angle in range(180, -1, -5):
        servo.ChangeDutyCycle(angle_to_duty(angle))
        time.sleep(0.02)
    servo.ChangeDutyCycle(0)

def restart_program():
    print("[INFO] Restarting program...")
    python = sys.executable
    os.execl(python, python, *sys.argv)

# Initialize LCD
lcd_init()
lcd_display("SmartDoor System", LINE_1)
lcd_display("Initializing...", LINE_2)
time.sleep(2)

# Initialize RFID and Face Recognition
reader = SimpleMFRC522()
face_detector = cv2.CascadeClassifier("haarcascade_frontalface_default.xml")
recognizer = cv2.face.LBPHFaceRecognizer_create()

def get_images_and_labels(path):
    image_paths = [os.path.join(path, f) for f in os.listdir(path) if f.endswith('.jpg')]
    face_samples = []
    ids = []
    
    for image_path in image_paths:
        img = Image.open(image_path).convert('L')
        img_np = np.array(img, 'uint8')
        
        # Detect faces with tight parameters
        faces = face_detector.detectMultiScale(
            img_np,
            scaleFactor=1.1,
            minNeighbors=5,
            minSize=(100, 100),
            flags=cv2.CASCADE_SCALE_IMAGE
        )
        
        for (x, y, w, h) in faces:
            # Tight crop with minimal background
            padding = 0.1  # Very tight crop
            x1 = max(0, int(x - w * padding))
            y1 = max(0, int(y - h * padding))
            x2 = min(img_np.shape[1], int(x + w * (1 + padding)))
            y2 = min(img_np.shape[0], int(y + h * (1 + padding)))
            
            face_roi = img_np[y1:y2, x1:x2]
            face_roi = cv2.resize(face_roi, (200, 200))
            face_samples.append(face_roi)
            ids.append(1)
            
    return face_samples, np.array(ids)

try:
    while True:
        lcd_display("Scan your", LINE_1)
        lcd_display("RFID Card...", LINE_2)

        # Initialize camera with optimal settings
        cam = cv2.VideoCapture(0)
        cam.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
        cam.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)
        cam.set(cv2.CAP_PROP_FPS, 30)

        # RFID Reading
        try:
            rfid_id, _ = reader.read()
            rfid_id = str(rfid_id)
            print(f"[INFO] RFID Scanned: {rfid_id}")
            lcd_display("RFID Found", LINE_1)
            lcd_display("Processing...", LINE_2)
        except Exception as e:
            print(f"[ERROR] RFID Read Failed: {e}")
            lcd_display("RFID Error", LINE_1)
            lcd_display("Try Again", LINE_2)
            time.sleep(2)
            continue

        # Check for dataset
        image_folder = os.path.join("dataset", rfid_id)
        if not os.path.exists(image_folder):
            print(f"[ERROR] No dataset for RFID {rfid_id}")
            lcd_display("No Data Found", LINE_1)
            lcd_display("Access Denied", LINE_2)
            GPIO.output(RED_LED_PIN, GPIO.HIGH)
            time.sleep(3)
            GPIO.output(RED_LED_PIN, GPIO.LOW)
            continue

        # Train with specific dataset
        print("[INFO] Training model...")
        lcd_display("Training Face", LINE_1)
        lcd_display("Please Wait...", LINE_2)
        
        faces, ids = get_images_and_labels(image_folder)
        if len(faces) == 0:
            print("[ERROR] No faces found in dataset")
            lcd_display("Invalid Dataset", LINE_1)
            lcd_display("Access Denied", LINE_2)
            time.sleep(3)
            continue
            
        recognizer.train(faces, ids)

        # Face Recognition
        print("[INFO] Face verification starting...")
        lcd_display("Look at Camera", LINE_1)
        lcd_display("Verifying...", LINE_2)
        
        matched = False
        start_time = time.time()
        timeout = 10  # Seconds to try recognition

        while time.time() - start_time < timeout and not matched:
            ret, img = cam.read()
            if not ret:
                print("[ERROR] Camera read failed")
                break

            img = cv2.flip(img, 1)
            gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
            gray = cv2.equalizeHist(gray)
            
            # Detect faces with tight parameters
            faces = face_detector.detectMultiScale(
                gray,
                scaleFactor=1.1,
                minNeighbors=5,
                minSize=(100, 100),
                flags=cv2.CASCADE_SCALE_IMAGE
            )

            for (x, y, w, h) in faces:
                # Tight crop with minimal background
                padding = 0.1
                x1 = max(0, int(x - w * padding))
                y1 = max(0, int(y - h * padding))
                x2 = min(gray.shape[1], int(x + w * (1 + padding)))
                y2 = min(gray.shape[0], int(y + h * (1 + padding)))
                
                face_roi = gray[y1:y2, x1:x2]
                face_roi = cv2.resize(face_roi, (200, 200))
                
                # Predict with confidence
                id_pred, confidence = recognizer.predict(face_roi)
                print(f"Confidence: {confidence}")

                if confidence < 40:  # Lower is better
                    name_file = os.path.join(image_folder, "name.txt")
                    person_name = open(name_file).read().strip() if os.path.exists(name_file) else "Authorized"
                    
                    print(f"[SUCCESS] {person_name} verified")
                    lcd_display("Access Granted", LINE_1)
                    lcd_display(f"Welcome {person_name[:10]}", LINE_2)
                    
                    # Visual feedback
                    GPIO.output(GREEN_LED_PIN, GPIO.HIGH)
                    GPIO.output(BUZZER_PIN, GPIO.HIGH)
                    time.sleep(0.1)
                    GPIO.output(BUZZER_PIN, GPIO.LOW)
                    
                    # Activate door mechanisms
                    rotate_servo()
                    GPIO.output(RELAY_PINS["relay1"], GPIO.HIGH)
                    GPIO.output(RELAY_PINS["relay3"], GPIO.HIGH)
                    
                    matched = True
                    break
                else:
                    print("[WARNING] Face not recognized")
                    GPIO.output(RED_LED_PIN, GPIO.HIGH)
                    GPIO.output(BUZZER_PIN, GPIO.HIGH)
                    time.sleep(0.1)
                    GPIO.output(BUZZER_PIN, GPIO.LOW)
                    time.sleep(0.1)
                    GPIO.output(BUZZER_PIN, GPIO.HIGH)
                    time.sleep(0.1)
                    GPIO.output(BUZZER_PIN, GPIO.LOW)
                    GPIO.output(RED_LED_PIN, GPIO.LOW)

            # Show camera feed
            cv2.imshow("Face Verification", img)
            if cv2.waitKey(1) & 0xFF == 27:
                break

        # Cleanup
        cam.release()
        cv2.destroyAllWindows()
        GPIO.output(GREEN_LED_PIN, GPIO.LOW)
        GPIO.output(RED_LED_PIN, GPIO.LOW)
        
        if not matched:
            lcd_display("Verification", LINE_1)
            lcd_display("Failed", LINE_2)
            time.sleep(2)

except KeyboardInterrupt:
    print("\n[INFO] Shutting down...")
    lcd_display("System", LINE_1)
    lcd_display("Shutting Down", LINE_2)
    servo.stop()
    GPIO.cleanup()
    cv2.destroyAllWindows()
