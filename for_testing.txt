import cv2
import os
import numpy as np
import RPi.GPIO as GPIO
from mfrc522 import SimpleMFRC522
import time
from PIL import Image
import pandas as pd
import threading
import requests

# GPIO Setup
GPIO.setwarnings(False)
GPIO.setmode(GPIO.BCM)

RELAY_PINS = {
    "relay1": 21,
    "relay2": 20,
    "relay3": 16,
    "relay4": 12,
}
SERVO_PIN = 17

for pin in RELAY_PINS.values():
    GPIO.setup(pin, GPIO.OUT)
    GPIO.output(pin, GPIO.LOW)

GPIO.setup(SERVO_PIN, GPIO.OUT)
servo = GPIO.PWM(SERVO_PIN, 50)
servo.start(0)

# Telegram Bot Setup
BOT_TOKEN = "8129064480:AAFZZjw7UTUrPgwUW33xu_B51MyJPg3WneY"
BASE_URL = f"https://api.telegram.org/bot{BOT_TOKEN}"
last_update_id = 0

def open_close():
    servo.ChangeDutyCycle(12.5)
    time.sleep(1)
    servo.ChangeDutyCycle(0)
    time.sleep(3)
    servo.ChangeDutyCycle(2.5)
    time.sleep(1)
    servo.ChangeDutyCycle(0)

def handle_telegram():
    global last_update_id
    while True:
        try:
            url = f"{BASE_URL}/getUpdates?offset={last_update_id + 1}&timeout=10"
            res = requests.get(url).json()
            for update in res.get("result", []):
                last_update_id = update["update_id"]
                msg = update.get("message", {}).get("text", "").lower()
                chat_id = update["message"]["chat"]["id"]
                print(f"[TELEGRAM] Received: {msg}")

                if msg.startswith("/relay"):
                    parts = msg.split("_")
                    if len(parts) == 2:
                        relay, state = parts
                        if relay in RELAY_PINS:
                            if state == "on":
                                GPIO.output(RELAY_PINS[relay], GPIO.HIGH)
                                response = f"{relay} turned ON"
                            elif state == "off":
                                GPIO.output(RELAY_PINS[relay], GPIO.LOW)
                                response = f"{relay} turned OFF"
                            else:
                                response = "Invalid command format"
                            requests.post(f"{BASE_URL}/sendMessage", data={"chat_id": chat_id, "text": response})
        except Exception as e:
            print(f"[ERROR] Telegram handler: {e}")
        time.sleep(2)

def recognize_and_act():
    reader = SimpleMFRC522()
    face_detector = cv2.CascadeClassifier("haarcascade_frontalface_default.xml")
    recognizer = cv2.face.LBPHFaceRecognizer_create()

    try:
        rfid_id, _ = reader.read()
        rfid_id = str(rfid_id)
        print(f"[INFO] RFID Scanned: {rfid_id}")
    except Exception as e:
        print(f"[ERROR] RFID read failed: {e}")
        return

    folder = os.path.join("dataset", rfid_id)
    if not os.path.exists(folder):
        print("[ERROR] No image dataset for this RFID")
        return

    def get_data(path):
        faces, ids = [], []
        for file in os.listdir(path):
            if file.endswith(".jpg"):
                img = Image.open(os.path.join(path, file)).convert("L")
                np_img = np.array(img, 'uint8')
                detected = face_detector.detectMultiScale(np_img)
                for (x, y, w, h) in detected:
                    faces.append(np_img[y:y+h, x:x+w])
                    ids.append(1)
        return faces, ids

    print("[INFO] Training...")
    faces, ids = get_data(folder)
    recognizer.train(faces, np.array(ids))

    user_name = "Unknown"
    try:
        df = pd.read_csv("user_data.csv")
        row = df[df['RFID_UID'] == int(rfid_id)]
        if not row.empty:
            user_name = row.iloc[0]['Name']
    except:
        pass

    cam = cv2.VideoCapture(0)
    cam.set(3, 640)
    cam.set(4, 480)

    print("[INFO] Starting face recognition...")
    matched = False
    while True:
        ret, img = cam.read()
        if not ret:
            continue
        img = cv2.flip(img, -1)
        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        faces = face_detector.detectMultiScale(gray, 1.3, 5)

        for (x, y, w, h) in faces:
            id_pred, conf = recognizer.predict(gray[y:y+h, x:x+w])
            if conf < 40:
                print(f"[MATCH] {user_name} - Confidence: {conf}")
                cv2.putText(img, user_name, (x, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 1, (255,255,255), 2)
                open_close()
                GPIO.output(RELAY_PINS["relay1"], GPIO.HIGH)
                GPIO.output(RELAY_PINS["relay2"], GPIO.HIGH)
                GPIO.output(RELAY_PINS["relay3"], GPIO.LOW)
                GPIO.output(RELAY_PINS["relay4"], GPIO.LOW)
                matched = True
            else:
                cv2.putText(img, "Unknown", (x, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 0, 255), 2)

        cv2.imshow("Face Recognition", img)
        if matched or cv2.waitKey(1) & 0xFF == 27:
            break

    cam.release()
    cv2.destroyAllWindows()

# Start
if __name__ == "__main__":
    threading.Thread(target=handle_telegram, daemon=True).start()
    while True:
        recognize_and_act()
