import cv2
import numpy as np
import tflite_runtime.interpreter as tflite
import os, json, time, csv, sys
from datetime import datetime
from mfrc522 import SimpleMFRC522
from RPLCD.i2c import CharLCD
from threading import Thread
from queue import Queue
import RPi.GPIO as GPIO

# === GPIO Setup ===
BUZZER_PIN = 17
GREEN_LED_PIN = 26
RED_LED_PIN = 19
SERVO_PIN = 21
LIGHT1_PIN = 22  # Example GPIO pin for LIGHT1
RELAY2_PIN = 23  # Example GPIO pin for RELAY2

GPIO.setwarnings(False)
GPIO.setmode(GPIO.BCM)
GPIO.setup(BUZZER_PIN, GPIO.OUT)
GPIO.setup(GREEN_LED_PIN, GPIO.OUT)
GPIO.setup(RED_LED_PIN, GPIO.OUT)
GPIO.setup(SERVO_PIN, GPIO.OUT)
GPIO.setup(LIGHT1_PIN, GPIO.OUT)  # Setup LIGHT1_PIN
GPIO.setup(RELAY2_PIN, GPIO.OUT)  # Setup RELAY2_PIN

GPIO.output(BUZZER_PIN, GPIO.LOW)
GPIO.output(GREEN_LED_PIN, GPIO.LOW)
GPIO.output(RED_LED_PIN, GPIO.LOW)
GPIO.output(LIGHT1_PIN, GPIO.LOW)  # Initialize LIGHT1 to LOW
GPIO.output(RELAY2_PIN, GPIO.LOW)  # Initialize RELAY2 to LOW

# === Servo Setup ===
servo = GPIO.PWM(SERVO_PIN, 50)
servo.start(0)

# === RFID Reader ===
reader = SimpleMFRC522()

# === Load TFLite model ===
interpreter = tflite.Interpreter(model_path="facenet.tflite")
interpreter.allocate_tensors()
input_details = interpreter.get_input_details()
output_details = interpreter.get_output_details()

# === Face Detection ===
face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + "haarcascade_frontalface_default.xml")

# === Preprocessing ===
def preprocess_face(face_img):
    # Resize the face image to the required size (160x160 for FaceNet)
    face = cv2.resize(face_img, (160, 160))
    
    # Normalize the pixel values (mean, std)
    face = face.astype('float32')
    mean, std = face.mean(), face.std()
    face = (face - mean) / std
    
    # Scale the values to the range [0, 255] and convert to UINT8
    face = np.clip(face * 128 + 128, 0, 255).astype(np.uint8)
    
    # Add batch dimension (since the model expects a batch of images)
    return np.expand_dims(face, axis=0)

def get_embedding(face_img):
    preprocessed = preprocess_face(face_img)
    interpreter.set_tensor(input_details[0]['index'], preprocessed)
    interpreter.invoke()
    embedding = interpreter.get_tensor(output_details[0]['index'])
    return embedding[0]

def cosine_similarity(a, b):
    return np.dot(a, b) / (np.linalg.norm(a) * np.linalg.norm(b))

# === Load known faces and embeddings ===
def load_known_faces():
    known_embeddings = {}
    for name in os.listdir("dataset"):
        path = f"dataset/{name}/face.jpg"
        if os.path.exists(path):
            img = cv2.imread(path)
            embedding = get_embedding(img)
            known_embeddings[name] = embedding
    return known_embeddings

known_faces = load_known_faces()

# === Load RFID mapping ===
with open("rfid_map.json", "r") as f:
    rfid_map = json.load(f)

# === CSV Setup ===
attendance_log_file = "/home/pi/Desktop/shyam/attendance_log.csv"
if not os.path.exists(attendance_log_file):
    with open(attendance_log_file, mode='w', newline='') as file:
        writer = csv.writer(file)
        writer.writerow(["Name", "RFID", "Date", "Time"])

# === Restart program ===
def restart_program():
    print("[INFO] Restarting program...")
    time.sleep(2)
    os.execv(sys.executable, ['python3'] + sys.argv)

# === Servo control function ===
def rotate_servo():
    print("[INFO] Rotating servo & activating relays...")
    GPIO.output(BUZZER_PIN, GPIO.HIGH)
    time.sleep(2)
    GPIO.output(BUZZER_PIN, GPIO.LOW)

    # Turn on LIGHT1 and RELAY2 when servo is triggered
    GPIO.output(LIGHT1_PIN, GPIO.HIGH)  # Turn on LIGHT1
    GPIO.output(RELAY2_PIN, GPIO.HIGH)  # Turn on RELAY2

    # Rotate servo to unlock position
    servo.ChangeDutyCycle(7.5)  # Servo to 90 degrees (unlock)
    time.sleep(1)

    # Reset servo back to closed position
    servo.ChangeDutyCycle(0)  # Reset to original position
    time.sleep(2)

    print("[INFO] Servo returned. Door unlocked.")

# === Main Logic ===
def main():
    cap = cv2.VideoCapture(0)
    if not cap.isOpened():
        print("[ERROR] Camera not accessible!")
        restart_program()

    print("[INFO] Ready for attendance")

    try:
        while True:
            GPIO.output(GREEN_LED_PIN, GPIO.LOW)
            print("Waiting for RFID...")
            id, text = reader.read()
            scanned_uid = str(id).strip()
            print("RFID scanned:", scanned_uid)

            matched_user = None
            for name, uid in rfid_map.items():
                if uid == scanned_uid:
                    matched_user = name
                    break

            if not matched_user:
                print("[ERROR] Unknown RFID")
                continue

            print(f"[INFO] RFID matched with {matched_user}, waiting for face...")

            while True:
                ret, frame = cap.read()
                if not ret:
                    print("[ERROR] Failed to capture frame.")
                    cap.release()
                    cv2.destroyAllWindows()
                    restart_program()
                cv2.imshow("Camera Feed", frame)

                gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
                faces = face_cascade.detectMultiScale(gray, scaleFactor=1.1, minNeighbors=5)

                if len(faces) == 0:
                    print("[WARNING] No face detected")
                    cv2.imshow("Camera Feed", frame)
                    continue

                # Use first detected face
                (x, y, w, h) = faces[0]
                face_img = frame[y:y+h, x:x+w]

                embedding = get_embedding(face_img)
                known_embedding = known_faces.get(matched_user)

                if known_embedding is None:
                    print("[ERROR] Face Not Found")
                    break

                similarity = cosine_similarity(embedding, known_embedding)
                print(f"[DEBUG] Similarity: {similarity:.4f}")

                if similarity > 0.8:
                    print(f"[SUCCESS] {matched_user} - Match: {similarity:.2f}")

                    current_time = datetime.now()
                    date = current_time.strftime("%Y-%m-%d")
                    time_str = current_time.strftime("%H:%M:%S")

                    with open(attendance_log_file, mode='a', newline='') as file:
                        writer = csv.writer(file)
                        writer.writerow([matched_user, scanned_uid, date, time_str])

                    GPIO.output(GREEN_LED_PIN, GPIO.HIGH)
                    time.sleep(2)
                    rotate_servo()  # Rotate servo to unlock door
                    cap.release()
                    cv2.destroyAllWindows()
                    return  # Restart loop for next person

                else:
                    print("[WARNING] Face not matched")
                    GPIO.output(BUZZER_PIN, GPIO.HIGH)
                    GPIO.output(RED_LED_PIN, GPIO.HIGH)
                    time.sleep(3)
                    cap.release()
                    cv2.destroyAllWindows()
                    restart_program()

                if cv2.waitKey(1) & 0xFF == ord('q'):
                    break

    except KeyboardInterrupt:
        print("[INFO] Interrupted by user.")
    finally:
        if cap.isOpened():
            cap.release()
            cv2.destroyAllWindows()

# === Run Main Loop with Restart Capability ===
while True:
    main()
