import cv2
import easyocr
import RPi.GPIO as GPIO
import time
import signal
import sys
import csv
import subprocess
import os
from datetime import datetime
from mfrc522 import SimpleMFRC522

# ---------------- Motor Setup ----------------
motor1_in1 = 21
motor1_in2 = 20
motor2_in1 = 16
motor2_in2 = 12
motor1_en = 5
motor2_en = 6
GPIO.cleanup()
GPIO.setmode(GPIO.BCM)
GPIO.setup([motor1_in1, motor1_in2, motor2_in1, motor2_in2, motor1_en, motor2_en], GPIO.OUT)
GPIO.output(motor1_en, GPIO.HIGH)
GPIO.output(motor2_en, GPIO.HIGH)

def move_forward():
    GPIO.output(motor1_in1, GPIO.HIGH)
    GPIO.output(motor1_in2, GPIO.LOW)
    GPIO.output(motor2_in1, GPIO.HIGH)
    GPIO.output(motor2_in2, GPIO.LOW)
    print("Moving forward...")

def move_backward():
    GPIO.output(motor1_in1, GPIO.LOW)
    GPIO.output(motor1_in2, GPIO.HIGH)
    GPIO.output(motor2_in1, GPIO.LOW)
    GPIO.output(motor2_in2, GPIO.HIGH)
    print("Moving backward...")

def stop_motors():
    GPIO.output(motor1_in1, GPIO.LOW)
    GPIO.output(motor1_in2, GPIO.LOW)
    GPIO.output(motor2_in1, GPIO.LOW)
    GPIO.output(motor2_in2, GPIO.LOW)
    print("Motors stopped.")

# ---------------- Ultrasonic Setup ----------------
GPIO_TRIGGER = 17
GPIO_ECHO = 27
GPIO.setup(GPIO_TRIGGER, GPIO.OUT)
GPIO.setup(GPIO_ECHO, GPIO.IN)

def distance():
    GPIO.output(GPIO_TRIGGER, True)
    time.sleep(0.00001)
    GPIO.output(GPIO_TRIGGER, False)

    start_time = time.time()
    stop_time = time.time()

    # Add timeouts to avoid hangs if sensor glitches
    timeout = time.time() + 0.05
    while GPIO.input(GPIO_ECHO) == 0 and time.time() < timeout:
        start_time = time.time()

    timeout = time.time() + 0.05
    while GPIO.input(GPIO_ECHO) == 1 and time.time() < timeout:
        stop_time = time.time()

    elapsed = stop_time - start_time
    dist = (elapsed * 34300) / 2
    return dist

def move_until_object(threshold=5.0):
    start = time.time()
    move_forward()
    while True:
        d = distance()
        print(f"Distance: {d:.2f} cm")
        if d <= threshold:
            stop_motors()
            forward_time = time.time() - start
            print("Object detected within threshold.")
            return forward_time
        time.sleep(0.05)

# ---------------- Servo Setup ----------------
SERVO_INDEX_PIN = 14
SERVO_DOOR_PIN = 26
GPIO.setup(SERVO_INDEX_PIN, GPIO.OUT)
GPIO.setup(SERVO_DOOR_PIN, GPIO.OUT)

servo_index = GPIO.PWM(SERVO_INDEX_PIN, 50)
servo_door = GPIO.PWM(SERVO_DOOR_PIN, 50)
servo_index.start(0)
servo_door.start(0)

# Exact angles for 3 parts
positions = {1: 0, 2: 80, 3: 180}
DOOR_OPEN = 60
DOOR_CLOSE = 180

def angle_to_duty(angle):
    return 2 + (angle / 18)

def move_servo_to(part):
    if part not in positions:
        print(f"Unknown part {part}, defaulting to part 1")
        part = 1
    angle = positions[part]
    duty = angle_to_duty(angle)
    servo_index.ChangeDutyCycle(duty)
    time.sleep(1.0)
    servo_index.ChangeDutyCycle(0)

def set_angle(angle, hold=0.5):
    duty = 2 + (angle / 18)
    GPIO.output(SERVO_DOOR_PIN, True)
    servo_door.ChangeDutyCycle(duty)
    time.sleep(hold)
    GPIO.output(SERVO_DOOR_PIN, False)
    servo_door.ChangeDutyCycle(0)

def door_open():
    set_angle(DOOR_OPEN, hold=1.0)
    print("Door opened")

def door_close():
    set_angle(DOOR_CLOSE, hold=1.0)
    print("Door closed")

# ---------------- CSV Users Setup ----------------
# CSV format: name,rfid,part
# Example:
# Alice,123456789,1
# Bob,987654321,2
# Charlie,555555555,3
def load_users(csv_file="users.csv"):
    users = {}
    if not os.path.exists(csv_file):
        print(f"CSV file '{csv_file}' not found. Proceeding with empty user database.")
        return users
    with open(csv_file, newline='') as f:
        reader = csv.DictReader(f)
        for row in reader:
            name = row.get('name', '').strip()
            rfid = row.get('rfid', '').strip()
            part_str = row.get('part', '').strip()
            if not name or not rfid:
                continue
            try:
                part = int(part_str) if part_str else 1
            except ValueError:
                part = 1
            users[rfid] = {'name': name, 'part': part}
    print(f"Loaded {len(users)} users from {csv_file}")
    return users

users_db = load_users("users.csv")

# ---------------- Bluetooth Speech ----------------
# Prefer high-quality TTS with pico2wave + paplay; fallback to espeak.
def speak(message):
    print(f"TTS: {message}")
    try:
        # Generate WAV with pico2wave
        tmp_wav = "/tmp/tts.wav"
        subprocess.run(["pico2wave", "-w", tmp_wav, message], check=True)
        # Play via PipeWire/PulseAudio default sink (your Bluetooth sink)
        subprocess.run(["paplay", tmp_wav], check=True)
    except Exception as e:
        print(f"pico2wave/paplay failed ({e}), trying espeak...")
        try:
            subprocess.run(["espeak", message], check=True)
        except Exception as e2:
            print(f"espeak failed: {e2}")

# ---------------- RFID Setup ----------------
reader_rfid = SimpleMFRC522()

def read_rfid():
    print("Place your RFID card near the reader...")
    id, text = reader_rfid.read()
    # Prefer numeric ID as stable key; fallback to text if present
    rfid_key = str(id).strip()
    print(f"Card ID: {id}, Data: {text}")
    return rfid_key

# ---------------- Dispense Logic (CSV validated) ----------------
def dispense_tablet(tag):
    now = datetime.now()
    hour = now.hour
    print(f"Dispensing tablet for tag {tag} at {now.strftime('%H:%M')}")

    if tag in users_db:
        name = users_db[tag]['name']
        part = users_db[tag]['part']
        print(f"Valid user: {name} → Part {part}")
        speak(f"Hello {name}, please take your tablets")
        move_servo_to(part)
        door_open()
        time.sleep(3)
        door_close()
        return

    # Invalid user
    print("Invalid user")
    speak("Invalid user")

    # Optional: Keep your time-based fallback logic for non-CSV tags
    if hour < 10:
        print("Morning scenario (<10 AM): Only door operation.")
        door_open()
        time.sleep(3)
        door_close()

    elif 12 <= hour < 14:
        print("Afternoon scenario (12–2 PM): Move part2 to part1.")
        move_servo_to(2)
        time.sleep(4)
        door_open()
        time.sleep(3)
        door_close()
        move_servo_to(1)

    elif 20 <= hour < 22:
        print("Evening scenario (8–10 PM): Move part3 to part1.")
        move_servo_to(3)
        time.sleep(1)
        move_servo_to(1)
        door_open()
        time.sleep(3)
        door_close()

    else:
        if 6 <= hour < 12:
            part = 1
        elif 12 <= hour < 18:
            part = 2
        else:
            part = 3
        print(f"Default scenario: Moving to part {part}.")
        move_servo_to(part)
        time.sleep(3)
        door_open()
        time.sleep(1)
        door_close()

# ---------------- OCR Setup ----------------
reader = easyocr.Reader(['en'])
cap = cv2.VideoCapture(0)
frame_count = 0

# ---------------- Safe Exit Handler ----------------
def safe_exit(sig, frame):
    print("Force exit detected, stopping motors...")
    try:
        stop_motors()
    except Exception:
        pass
    GPIO.output(motor1_en, GPIO.LOW)
    GPIO.output(motor2_en, GPIO.LOW)
    GPIO.cleanup()
    try:
        cap.release()
    except Exception:
        pass
    try:
        servo_index.stop()
        servo_door.stop()
    except Exception:
        pass
    sys.exit(0)

signal.signal(signal.SIGINT, safe_exit)
signal.signal(signal.SIGTERM, safe_exit)

# ---------------- Main Flow ----------------
try:
    while True:
        ret, frame = cap.read()
        if not ret:
            print("Camera frame not available; retrying...")
            time.sleep(0.2)
            continue

        frame_count += 1
        if frame_count % 10 == 0:
            results = reader.readtext(frame)
            for (_, text, prob) in results:
                digits = ''.join([c for c in text if c.isdigit()])
                if digits == "2":
                    print("Digit '2' detected!")
                    forward_time = move_until_object(threshold=13.0)
                    tag = read_rfid()
                    dispense_tablet(tag)
                    print("Returning to original position...")
                    move_backward()
                    time.sleep(forward_time)
                    stop_motors()
                    print("Process complete.")
                    # Break out of OCR loop to avoid repeated triggers
                    break

except Exception as e:
    print(f"Error occurred: {e}")

finally:
    try:
        cap.release()
    except Exception:
        pass
    try:
        servo_index.stop()
        servo_door.stop()
    except Exception:
        pass
    stop_motors()
    GPIO.output(motor1_en, GPIO.LOW)
    GPIO.output(motor2_en, GPIO.LOW)
    GPIO.cleanup()
    print("Motors stopped and GPIO cleaned up.")
